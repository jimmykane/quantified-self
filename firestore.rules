rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function isCoach(userID) {
      return exists(/databases/$(database)/documents/coaches/$(request.auth.uid)/athletes/$(userID)) && get(/databases/$(database)/documents/coaches/$(request.auth.uid)/athletes/$(userID)).data.accepted == true;
    }
    
    function isBasic() {
      return request.auth != null && request.auth.token.stripeRole == 'basic';
    }

    function isPro() {
      return request.auth != null && request.auth.token.stripeRole == 'pro';
    }

    function isSubscribed() {
      return request.auth != null && request.auth.token.stripeRole in ['basic', 'pro'];
    }

    function isFree() {
      return request.auth != null && !('stripeRole' in request.auth.token);
    }

    function isAdmin() {
      return request.auth != null && request.auth.token.admin == true;
    }

    // Make sure the uid of the requesting user matches name of the user
    // document. The wildcard expression {userId} makes the userId variable
    // available in rules.
    match /users/{userID} {
      allow read: if resource.data.privacy == 'public';
      allow read: if isCoach(userID) == true;
      allow read, write: if request.auth.uid == userID;
      allow create: if request.auth.uid != null;
      
      // Stripe Extension Collections
      match /checkout_sessions/{id} {
        allow read, write: if request.auth.uid == userID;
      }
      match /subscriptions/{id} {
        allow read: if request.auth.uid == userID;
      }
      match /payments/{id} {
        allow read: if request.auth.uid == userID;
      }
      
      // Legal Agreements (Write-Once / Monotonic)
      match /legal/agreements {
        allow read: if request.auth.uid == userID;
        
        function isValidLegalAgreement() {
           return request.resource.data.keys().hasOnly([
             'acceptedPrivacyPolicy', 
             'acceptedDataPolicy', 
             'acceptedTrackingPolicy', 
             'acceptedDiagnosticsPolicy', 
             'acceptedTos'
           ]) &&
           (request.resource.data.get('acceptedPrivacyPolicy', true) == true) &&
           (request.resource.data.get('acceptedDataPolicy', true) == true) &&
           (request.resource.data.get('acceptedTrackingPolicy', true) == true) &&
           (request.resource.data.get('acceptedDiagnosticsPolicy', true) == true) &&
           (request.resource.data.get('acceptedTos', true) == true);
        }

        allow create: if request.auth.uid == userID && isValidLegalAgreement();
        
        allow update: if request.auth.uid == userID 
          && request.resource.data.diff(resource.data).affectedKeys().hasOnly([
             'acceptedPrivacyPolicy', 
             'acceptedDataPolicy', 
             'acceptedTrackingPolicy', 
             'acceptedDiagnosticsPolicy', 
             'acceptedTos'
           ])
          && (request.resource.data.get('acceptedPrivacyPolicy', true) == true)
          && (request.resource.data.get('acceptedDataPolicy', true) == true)
          && (request.resource.data.get('acceptedTrackingPolicy', true) == true)
          && (request.resource.data.get('acceptedDiagnosticsPolicy', true) == true)
          && (request.resource.data.get('acceptedTos', true) == true);
           
      }

      // System Status (Admin Only)
      match /system/status {
         allow read: if request.auth.uid == userID;
         allow write: if false; // Only Cloud Functions (Admin SDK)
      }

        match /events/{eventID} {
          allow read: if resource.data.privacy == 'public';
          allow read: if isCoach(userID) == true;
          // RESTRICTED ACCESS: Must be owner AND have a valid role (Free, Basic, or PRO)
          // TEMPORARILY DISABLED FOR TESTING - Re-enable when ready to enforce paywall
          // allow read, write: if request.auth.uid == userID && isSubscribed();
          allow read, write: if request.auth.uid == userID;
          function eventData() {
            return get(/databases/$(database)/documents/users/$(userID)/events/$(eventID)).data
          }


          // Restoring metaData inside events
          match /metaData/{document=**} {
            allow read: if request.auth.uid == userID;
          }


           // New Flat Activities Collection
           // @note: This is the new way to access activities
          }
          
          match /activities/{activityID} {
            // New Flat Activities Collection
            allow read: if isCoach(userID) == true; // @todo restrict to coach/privacy?
            allow read, write: if request.auth.uid == userID;
          }




        match /meta/{document=**} {
          allow read: if request.auth.uid == userID;
        }
    }

    match /customers/{userID} {
      allow read: if request.auth.uid == userID;
      allow update: if request.auth.uid == userID && 
        (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['stripeId', 'stripeLink']) || 
         ((!('stripeId' in request.resource.data) || request.resource.data.stripeId == null) &&
          (!('stripeLink' in request.resource.data) || request.resource.data.stripeLink == null)));
      match /checkout_sessions/{id} {
        allow read, write: if request.auth.uid == userID;
      }
      match /subscriptions/{id} {
        allow read: if request.auth.uid == userID;
      }
      match /payments/{id} {
        allow read: if request.auth.uid == userID;
      }
    }
    
    match /products/{id} {
      allow read: if true;
      match /prices/{id} {
        allow read: if true;
      }
      match /tax_rates/{id} {
        allow read: if true;
      }
    }


    match /suuntoAppAccessTokens/{userID} {
      allow read, write: if request.auth.uid == userID && request.auth.token.firebase.sign_in_provider != 'anonymous';
       match /tokens/{document=**} {
          allow read, write: if request.auth.uid == userID && request.auth.token.firebase.sign_in_provider != 'anonymous';
       }
    }

    match /COROSAPIAccessTokens/{userID} {
      allow read, write: if request.auth.uid == userID && request.auth.token.firebase.sign_in_provider != 'anonymous';
       match /tokens/{document=**} {
          allow read, write: if request.auth.uid == userID && request.auth.token.firebase.sign_in_provider != 'anonymous';
       }
    }

    match /garminHealthAPITokens/{userID} {
      allow read, write: if request.auth.uid == userID && request.auth.token.firebase.sign_in_provider != 'anonymous';
    }

    match /garminHealthAPIActivityQueue/{userID} {
      allow read: if isAdmin();
      allow write: if false;
    }

    match /COROSAPIWorkoutQueue/{userID} {
      allow read: if isAdmin();
      allow write: if false;
    }

    match /COROSAPIHistoryImportWorkoutQueue/{userID} {
      allow read: if isAdmin();
      allow write: if false;
    }

    match /suuntoAppWorkoutQueue/{userID} {
      allow read: if isAdmin();
      allow write: if false;
    }

    match /suuntoAppHistoryImportActivityQueue/{userID} {
      allow read: if isAdmin();
      allow write: if false;
    }


    // @todo perhaps restrict to user ID
    match /userAccountPrivileges/{document=**} {
      allow write: if false;
      allow read: if true;
    }


    match /coaches/{userID} {
      allow read, write: if request.auth.uid == userID && request.auth.token.firebase.sign_in_provider != 'anonymous';
       match /athletes/{athleteUserID} {
          allow read,delete: if request.auth.uid == userID && request.auth.token.firebase.sign_in_provider != 'anonymous';
          allow read, write: if request.auth.uid == athleteUserID && request.auth.token.firebase.sign_in_provider != 'anonymous';
       }
    }
  }
}

service firebase.storage {
  match /b/{bucket}/o {
    match /assets/{allPaths=**} {
       allow read;
    }
  }
}
